{"version":3,"sources":["node_modules/browser-pack/_prelude.js","webglqualifier.min.js","src/WebGLQualifier.js","src/shader/default.fragment.glsl","src/shader/default.vertex.glsl"],"names":["f","exports","module","define","amd","g","window","global","self","this","WebGLQualifier","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","_defaultVertex","_defaultVertex2","_defaultFragment","_defaultFragment2","options","assign","benchmarkDuration","benchmarkVertexShader","benchmarkFragmentShader","qualityRange","qualityNames","showBenchmark","webGLenabled","_checkWebGLEnabled","hardwareAccelerated","_checkHardwareAccelerated","benchmarkFPS","currentQualityValue","currentQualityName","value","WebGLRenderingContext","canvas","document","createElement","names","gl","getContext","getParameter","isIE11","test","navigator","userAgent","enabled","$","context","antialias","stencil","failIfMajorPerformanceCaveat","fps","qualityIndex","callback","_this","isWebGLenabled","isHardwareAccelerated","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","c","setTimeout","width","height","style","position","visibility","body","appendChild","aspect","viewport","clearColor","clear","COLOR_BUFFER_BIT","v","_f","vs","createShader","VERTEX_SHADER","shaderSource","compileShader","fs","FRAGMENT_SHADER","program","createProgram","attachShader","linkProgram","error","getShaderParameter","COMPILE_STATUS","getProgramParameter","LINK_STATUS","removeChild","firstTime","Date","now","nbFrames","vertices","Float32Array","vbuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","triCount","numItems","useProgram","time","resolution","getUniformLocation","uniform2f","aVertexPosition","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","FLOAT","drawArrays","TRIANGLES","_getQualityValue","_getQualityName","./shader/default.fragment.glsl","./shader/default.vertex.glsl","2","3"],"mappings":"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","file":"webglqualifier.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.WebGLQualifier = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _defaultVertex = require('./shader/default.vertex.glsl');\n\nvar _defaultVertex2 = _interopRequireDefault(_defaultVertex);\n\nvar _defaultFragment = require('./shader/default.fragment.glsl');\n\nvar _defaultFragment2 = _interopRequireDefault(_defaultFragment);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar WebGLQualifier = function () {\n\tfunction WebGLQualifier(options) {\n\t\t_classCallCheck(this, WebGLQualifier);\n\n\t\tthis.options = Object.assign({}, {\n\t\t\tbenchmarkDuration: 2,\n\t\t\tbenchmarkVertexShader: _defaultVertex2.default,\n\t\t\tbenchmarkFragmentShader: _defaultFragment2.default,\n\t\t\tqualityRange: [15, 30, 45, 56],\n\t\t\tqualityNames: ['ultralow', 'low', 'medium', 'high', 'ultrahigh'],\n\t\t\tshowBenchmark: false\n\t\t}, options);\n\n\t\tthis.webGLenabled = this._checkWebGLEnabled();\n\t\tthis.hardwareAccelerated = this._checkHardwareAccelerated();\n\n\t\tthis.benchmarkFPS = 0;\n\t\tthis.currentQualityValue = -1;\n\t\tthis.currentQualityName = '';\n\t}\n\n\t_createClass(WebGLQualifier, [{\n\t\tkey: '_checkWebGLEnabled',\n\t\tvalue: function _checkWebGLEnabled() {\n\t\t\tif (!!window.WebGLRenderingContext) {\n\t\t\t\tvar canvas = document.createElement(\"canvas\"),\n\t\t\t\t    names = [\"webgl\", \"experimental-webgl\", \"moz-webgl\"],\n\t\t\t\t    gl = false;\n\n\t\t\t\tfor (var i in names) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tgl = canvas.getContext(names[i]);\n\t\t\t\t\t\tif (gl && typeof gl.getParameter == \"function\") {\n\t\t\t\t\t\t\t// WebGL is enabled\n\t\t\t\t\t\t\t// return true;\n\t\t\t\t\t\t\treturn names[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {}\n\t\t\t\t}\n\n\t\t\t\t// WebGL is supported, but disabled\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// WebGL not supported\n\t\t\treturn false;\n\t\t}\n\t}, {\n\t\tkey: '_checkHardwareAccelerated',\n\t\tvalue: function _checkHardwareAccelerated() {\n\t\t\t// check software rendering for IE11\n\t\t\tvar isIE11 = /Trident.*rv[ :]*11\\./.test(window.navigator.userAgent);\n\n\t\t\tif (this.enabled && isIE11) {\n\t\t\t\tvar canvas = $('<canvas></canvas>')[0];\n\t\t\t\tvar context = canvas.getContext(this.enabled, { antialias: false, stencil: true, failIfMajorPerformanceCaveat: true });\n\n\t\t\t\t// damn, no hardware acceleration !..\n\t\t\t\tif (context == null) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}, {\n\t\tkey: '_getQualityValue',\n\t\tvalue: function _getQualityValue(fps) {\n\t\t\tif (!fps) {\n\t\t\t\tfps = this.benchmarkFPS;\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < this.options.qualityRange.length; i++) {\n\t\t\t\tif (fps < this.options.qualityRange[i]) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.options.qualityRange.length;\n\t\t}\n\t}, {\n\t\tkey: '_getQualityName',\n\t\tvalue: function _getQualityName(qualityIndex) {\n\t\t\treturn this.options.qualityNames[qualityIndex];\n\t\t}\n\n\t\t// start benchmark\n\t\t// return canvas used for benchmark\n\n\t}, {\n\t\tkey: 'benchmark',\n\t\tvalue: function benchmark(callback) {\n\t\t\tvar _this = this;\n\n\t\t\t// no webgl\n\t\t\tif (!this.isWebGLenabled() || !this.isHardwareAccelerated()) {\n\t\t\t\tthis.benchmarkFPS = 0;\n\t\t\t\tthis.currentQualityValue = -1;\n\t\t\t\tthis.currentQualityName = '';\n\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(this.benchmarkFPS, this.currentQualityName, this.currentQualityValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// requestAnimFrame shim\n\t\t\tvar requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (c) {\n\t\t\t\twindow.setTimeout(c, 15);\n\t\t\t};\n\n\t\t\t// create webgl context on the canvas element\n\t\t\tvar canvas = document.createElement(\"canvas\");\n\t\t\tcanvas.width = 800;\n\t\t\tcanvas.height = 600;\n\t\t\tcanvas.style.position = 'absolute';\n\t\t\tif (this.options.showBenchmark) {\n\t\t\t\tcanvas.style.visibility = 'visible';\n\t\t\t} else {\n\t\t\t\tcanvas.style.visibility = 'hidden';\n\t\t\t\tcanvas.style.width = '1px';\n\t\t\t\tcanvas.style.height = '1px';\n\t\t\t}\n\n\t\t\t// add canvas to DOM\n\t\t\t// if not added, performance won't be real\n\t\t\tdocument.body.appendChild(canvas);\n\n\t\t\tvar aspect = canvas.width / canvas.height;\n\t\t\tvar gl = canvas.getContext(\"experimental-webgl\");\n\n\t\t\tgl.viewport(0, 0, canvas.width, canvas.height);\n\t\t\tgl.clearColor(0, 0, 0, 1);\n\t\t\tgl.clear(gl.COLOR_BUFFER_BIT);\n\n\t\t\t// get the vertex and fragment shader source\n\t\t\tvar v = this.options.benchmarkVertexShader;\n\t\t\tvar _f = this.options.benchmarkFragmentShader;\n\n\t\t\t// compile and link the shaders\n\t\t\tvar vs = gl.createShader(gl.VERTEX_SHADER);\n\t\t\tgl.shaderSource(vs, v);\n\t\t\tgl.compileShader(vs);\n\n\t\t\tvar fs = gl.createShader(gl.FRAGMENT_SHADER);\n\t\t\tgl.shaderSource(fs, _f);\n\t\t\tgl.compileShader(fs);\n\n\t\t\tvar program = gl.createProgram();\n\t\t\tgl.attachShader(program, vs);\n\t\t\tgl.attachShader(program, fs);\n\t\t\tgl.linkProgram(program);\n\n\t\t\t// debug shader compile status\n\t\t\tvar error = false;\n\t\t\tif (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\n\t\t\t\terror = true;\n\t\t\t\t//console.log(gl.getShaderInfoLog(vs));\n\t\t\t}\n\n\t\t\tif (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\n\t\t\t\terror = true;\n\t\t\t\t//console.log(gl.getShaderInfoLog(fs));\n\t\t\t}\n\n\t\t\tif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n\t\t\t\terror = true;\n\t\t\t\t//console.log(gl.getProgramInfoLog(program));\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\t// remove canvas from DOM\n\t\t\t\tdocument.body.removeChild(canvas);\n\n\t\t\t\tthis.benchmarkFPS = 0;\n\t\t\t\tthis.currentQualityValue = -1;\n\t\t\t\tthis.currentQualityName = '';\n\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(this.benchmarkFPS, this.currentQualityName, this.currentQualityValue);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// gl.getParameter( glExtensionDebugRendererInfo.UNMASKED_RENDERER_WEBGL )\n\t\t\t// gl.getParameter( glExtensionDebugRendererInfo.UNMASKED_VENDOR_WEBGL )\n\n\t\t\tvar firstTime = Date.now();\n\t\t\tvar nbFrames = 0;\n\t\t\t(_f = function f() {\n\t\t\t\tnbFrames++;\n\n\t\t\t\t// create vertices to fill the canvas with a single quad\n\t\t\t\tvar vertices = new Float32Array([-1, 1 * aspect, 1, 1 * aspect, 1, -1 * aspect, -1, 1 * aspect, 1, -1 * aspect, -1, -1 * aspect]);\n\n\t\t\t\tvar vbuffer = gl.createBuffer();\n\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);\n\t\t\t\tgl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n\n\t\t\t\tvar triCount = 2,\n\t\t\t\t    numItems = vertices.length / triCount;\n\n\t\t\t\tgl.useProgram(program);\n\n\t\t\t\tvar time = (Date.now() - firstTime) / 1000.0;\n\t\t\t\t//program.time = gl.getUniformLocation(program, \"time\");\n\t\t\t\t//gl.uniform1f(program.time, time);\n\t\t\t\tprogram.resolution = gl.getUniformLocation(program, \"iResolution\");\n\t\t\t\tgl.uniform2f(program.resolution, canvas.width, canvas.height);\n\n\t\t\t\tprogram.aVertexPosition = gl.getAttribLocation(program, \"aVertexPosition\");\n\t\t\t\tgl.enableVertexAttribArray(program.aVertexPosition);\n\t\t\t\tgl.vertexAttribPointer(program.aVertexPosition, triCount, gl.FLOAT, false, 0, 0);\n\n\t\t\t\tgl.drawArrays(gl.TRIANGLES, 0, numItems);\n\n\t\t\t\tif (time >= _this.options.benchmarkDuration) {\n\t\t\t\t\t// remove canvas from DOM\n\t\t\t\t\tdocument.body.removeChild(canvas);\n\n\t\t\t\t\t_this.benchmarkFPS = nbFrames / time;\n\t\t\t\t\t_this.currentQualityValue = _this._getQualityValue(_this.benchmarkFPS);\n\t\t\t\t\t_this.currentQualityName = _this._getQualityName(_this.currentQualityValue);\n\n\t\t\t\t\tif (callback) {\n\t\t\t\t\t\tcallback(_this.benchmarkFPS, _this.currentQualityName, _this.currentQualityValue);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trequestAnimationFrame(_f);\n\t\t\t\t}\n\t\t\t})();\n\n\t\t\treturn canvas;\n\t\t}\n\t}, {\n\t\tkey: 'isWebGLenabled',\n\t\tvalue: function isWebGLenabled() {\n\t\t\treturn this.webGLenabled;\n\t\t}\n\t}, {\n\t\tkey: 'isHardwareAccelerated',\n\t\tvalue: function isHardwareAccelerated() {\n\t\t\treturn this.hardwareAccelerated;\n\t\t}\n\t}]);\n\n\treturn WebGLQualifier;\n}();\n\nmodule.exports = WebGLQualifier;\n\n},{\"./shader/default.fragment.glsl\":2,\"./shader/default.vertex.glsl\":3}],2:[function(require,module,exports){\nmodule.exports = \"// simple raytracing example\\n// a sphere + a plane\\n// if it's hard to deal with this shader, be assured your gc is slow...\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nuniform vec2 iResolution;\\n\\n//void main() { gl_FragColor = vec4(1.0); }\\n\\nfloat sdPlane(vec3 p) {\\n    return p.y;\\n}\\n\\nfloat sdSphere(vec3 p, float s) {\\n    return length(p) - s;\\n}\\n\\n//----------------------------------------------------------------------\\n\\nvec2 opU( vec2 d1, vec2 d2 ) {\\n    return (d1.x<d2.x) ? d1 : d2;\\n}\\n\\n//----------------------------------------------------------------------\\n\\nvec2 map(in vec3 pos) {\\n    return opU(vec2(sdPlane(pos), 1.0), vec2(sdSphere(pos - vec3(0.0,0.25, 0.0), 0.25), 46.9));\\n}\\n\\nvec2 castRay( in vec3 ro, in vec3 rd ) {\\n    float tmin = 1.0;\\n    float tmax = 20.0;\\n\\n    float precis = 0.002;\\n    float t = tmin;\\n    float m = -1.0;\\n    for( int i=0; i<50; i++ ) {\\n        vec2 res = map( ro+rd*t );\\n        if( res.x<precis || t>tmax ) break;\\n        t += res.x;\\n        m = res.y;\\n    }\\n\\n    if( t>tmax ) m=-1.0;\\n    return vec2( t, m );\\n}\\n\\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\\n    float res = 1.0;\\n    float t = mint;\\n    for( int i=0; i<16; i++ )\\n    {\\n        float h = map( ro + rd*t ).x;\\n        res = min( res, 8.0*h/t );\\n        t += clamp( h, 0.02, 0.10 );\\n        if( h<0.001 || t>tmax ) break;\\n    }\\n    return clamp( res, 0.0, 1.0 );\\n\\n}\\n\\nvec3 calcNormal( in vec3 pos ) {\\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\\n    vec3 nor = vec3(\\n    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\\n    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\\n    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\\n    return normalize(nor);\\n}\\n\\nfloat calcAO( in vec3 pos, in vec3 nor ) {\\n    float occ = 0.0;\\n    float sca = 1.0;\\n    for( int i=0; i<5; i++ )\\n    {\\n        float hr = 0.01 + 0.12*float(i)/4.0;\\n        vec3 aopos =  nor * hr + pos;\\n        float dd = map( aopos ).x;\\n        occ += -(dd-hr)*sca;\\n        sca *= 0.95;\\n    }\\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\\n}\\n\\nvec3 render( in vec3 ro, in vec3 rd ) {\\n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\\n    vec2 res = castRay(ro,rd);\\n    float t = res.x;\\n    float m = res.y;\\n    if( m>-0.5 ) {\\n        vec3 pos = ro + t*rd;\\n        vec3 nor = calcNormal( pos );\\n        vec3 ref = reflect( rd, nor );\\n\\n        // material\\n        col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\\n\\n        if( m<1.5 )\\n        {\\n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\\n            col = 0.4 + 0.1*f*vec3(1.0);\\n        }\\n\\n        // lighitng\\n        float occ = calcAO( pos, nor );\\n        vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\\n        float dom = smoothstep( -0.1, 0.1, ref.y );\\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\\n\\n        dif *= softshadow( pos, lig, 0.02, 2.5 );\\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\\n\\n        vec3 lin = vec3(0.0);\\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\\n        lin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\\n        col = col*lin;\\n\\n        col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\\n\\n    }\\n\\n    return vec3( clamp(col,0.0,1.0) );\\n}\\n\\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\\n    vec3 cw = normalize(ta-ro);\\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\\n    vec3 cu = normalize( cross(cw,cp) );\\n    vec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, cw );\\n}\\n\\nvoid main() {\\n    vec2 q = gl_FragCoord.xy/iResolution.xy;\\n    vec2 p = -1.0+2.0*q;\\n    p.x *= iResolution.x/iResolution.y;\\n\\n    float time = 15.0;// + iGlobalTime;\\n\\n    // camera\\n    vec3 ro = vec3(-0.5+1.5*cos(0.1*time), 1.0, -0.5 + 1.5*sin(0.1*time));\\n    vec3 ta = vec3(0.0, 0.0, 0.0);\\n\\n    // camera-to-world transformation\\n    mat3 ca = setCamera( ro, ta, 0.0 );\\n\\n    // ray direction\\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\\n\\n    // render\\n    vec3 col = render( ro, rd );\\n\\n    col = pow( col, vec3(0.4545) );\\n\\n    gl_FragColor = vec4(col, 1.0);\\n}\\n\";\n\n},{}],3:[function(require,module,exports){\nmodule.exports = \"attribute vec2 aVertexPosition;\\n\\nvoid main() {\\n    gl_Position = vec4(aVertexPosition, 0.0, 1.0);\\n}\\n\";\n\n},{}]},{},[1])(1)\n});\n\n","import vertexShader from './shader/default.vertex.glsl';\nimport fragmentShader from './shader/default.fragment.glsl';\n\nclass WebGLQualifier {\n\n\tconstructor(options) {\n\t\tthis.options = Object.assign({}, {\n\t\t\tbenchmarkDuration: 2,\n\t\t\tbenchmarkVertexShader: vertexShader,\n\t\t\tbenchmarkFragmentShader: fragmentShader,\n\t\t\tqualityRange: [15, 30, 45, 56],\n\t\t\tqualityNames: ['ultralow', 'low', 'medium', 'high', 'ultrahigh'],\n\t\t\tshowBenchmark: false\n\t\t}, options);\n\n\t\tthis.webGLenabled = this._checkWebGLEnabled();\n\t\tthis.hardwareAccelerated = this._checkHardwareAccelerated();\n\n\t\tthis.benchmarkFPS = 0;\n\t\tthis.currentQualityValue = -1;\n\t\tthis.currentQualityName = '';\n\t}\n\n\t_checkWebGLEnabled() {\n\t\tif (!!window.WebGLRenderingContext) {\n\t\t\tlet canvas = document.createElement(\"canvas\"),\n\t\t\t\tnames = [\"webgl\", \"experimental-webgl\", \"moz-webgl\"],\n\t\t\t\tgl = false;\n\n\t\t\tfor (let i in names) {\n\t\t\t\ttry {\n\t\t\t\t\tgl = canvas.getContext(names[i]);\n\t\t\t\t\tif (gl && typeof gl.getParameter == \"function\") {\n\t\t\t\t\t\t// WebGL is enabled\n\t\t\t\t\t\t// return true;\n\t\t\t\t\t\treturn names[i];\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// WebGL is supported, but disabled\n\t\t\treturn false;\n\t\t}\n\n\t\t// WebGL not supported\n\t\treturn false;\n\t}\n\n\t_checkHardwareAccelerated() {\n\t\t// check software rendering for IE11\n\t\tlet isIE11 = /Trident.*rv[ :]*11\\./.test(window.navigator.userAgent);\n\n\t\tif (this.enabled && isIE11) {\n\t\t\tlet canvas = $('<canvas></canvas>')[0];\n\t\t\tlet context = canvas.getContext(this.enabled, {antialias: false, stencil: true, failIfMajorPerformanceCaveat: true});\n\n\t\t\t// damn, no hardware acceleration !..\n\t\t\tif (context == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t_getQualityValue(fps) {\n\t\tif (!fps) {\n\t\t\tfps = this.benchmarkFPS;\n\t\t}\n\n\t\tfor (let i = 0; i < this.options.qualityRange.length; i++) {\n\t\t\tif (fps < this.options.qualityRange[i]) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn this.options.qualityRange.length;\n\t}\n\n\t_getQualityName(qualityIndex) {\n\t\treturn this.options.qualityNames[qualityIndex];\n\t}\n\n\t// start benchmark\n\t// return canvas used for benchmark\n\tbenchmark(callback) {\n\t\t// no webgl\n\t\tif (!this.isWebGLenabled() || !this.isHardwareAccelerated()) {\n\t\t\tthis.benchmarkFPS = 0;\n\t\t\tthis.currentQualityValue = -1;\n\t\t\tthis.currentQualityName = '';\n\n\t\t\tif (callback) {\n\t\t\t\tcallback(this.benchmarkFPS, this.currentQualityName, this.currentQualityValue);\n\t\t\t}\n\t\t}\n\n\t\t// requestAnimFrame shim\n\t\tlet requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame ||\n\t\t\twindow.mozRequestAnimationFrame || window.msRequestAnimationFrame ||\n\t\t\tfunction (c) {\n\t\t\t\twindow.setTimeout(c, 15)\n\t\t\t};\n\n\t\t// create webgl context on the canvas element\n\t\tlet canvas = document.createElement(\"canvas\");\n\t\tcanvas.width = 800;\n\t\tcanvas.height = 600;\n\t\tcanvas.style.position = 'absolute';\n\t\tif (this.options.showBenchmark) {\n\t\t\tcanvas.style.visibility = 'visible';\n\t\t} else {\n\t\t\tcanvas.style.visibility = 'hidden';\n\t\t\tcanvas.style.width = '1px';\n\t\t\tcanvas.style.height = '1px';\n\t\t}\n\n\t\t// add canvas to DOM\n\t\t// if not added, performance won't be real\n\t\tdocument.body.appendChild(canvas);\n\n\t\tlet aspect = canvas.width / canvas.height;\n\t\tlet gl = canvas.getContext(\"experimental-webgl\");\n\n\t\tgl.viewport(0, 0, canvas.width, canvas.height);\n\t\tgl.clearColor(0, 0, 0, 1);\n\t\tgl.clear(gl.COLOR_BUFFER_BIT);\n\n\t\t// get the vertex and fragment shader source\n\t\tlet v = this.options.benchmarkVertexShader;\n\t\tlet f = this.options.benchmarkFragmentShader;\n\n\t\t// compile and link the shaders\n\t\tlet vs = gl.createShader(gl.VERTEX_SHADER);\n\t\tgl.shaderSource(vs, v);\n\t\tgl.compileShader(vs);\n\n\t\tlet fs = gl.createShader(gl.FRAGMENT_SHADER);\n\t\tgl.shaderSource(fs, f);\n\t\tgl.compileShader(fs);\n\n\t\tlet program = gl.createProgram();\n\t\tgl.attachShader(program, vs);\n\t\tgl.attachShader(program, fs);\n\t\tgl.linkProgram(program);\n\n\t\t// debug shader compile status\n\t\tlet error = false;\n\t\tif (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\n\t\t\terror = true;\n\t\t\t//console.log(gl.getShaderInfoLog(vs));\n\t\t}\n\n\t\tif (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\n\t\t\terror = true;\n\t\t\t//console.log(gl.getShaderInfoLog(fs));\n\t\t}\n\n\t\tif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n\t\t\terror = true;\n\t\t\t//console.log(gl.getProgramInfoLog(program));\n\t\t}\n\t\tif (error) {\n\t\t\t// remove canvas from DOM\n\t\t\tdocument.body.removeChild(canvas);\n\n\t\t\tthis.benchmarkFPS = 0;\n\t\t\tthis.currentQualityValue = -1;\n\t\t\tthis.currentQualityName = '';\n\n\t\t\tif (callback) {\n\t\t\t\tcallback(this.benchmarkFPS, this.currentQualityName, this.currentQualityValue);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// gl.getParameter( glExtensionDebugRendererInfo.UNMASKED_RENDERER_WEBGL )\n\t\t// gl.getParameter( glExtensionDebugRendererInfo.UNMASKED_VENDOR_WEBGL )\n\n\t\tlet firstTime = Date.now();\n\t\tlet nbFrames = 0;\n\t\t(f = () => {\n\t\t\tnbFrames++;\n\n\t\t\t// create vertices to fill the canvas with a single quad\n\t\t\tlet vertices = new Float32Array(\n\t\t\t\t[\n\t\t\t\t\t-1, 1 * aspect, 1, 1 * aspect, 1, -1 * aspect,\n\t\t\t\t\t-1, 1 * aspect, 1, -1 * aspect, -1, -1 * aspect\n\t\t\t\t]);\n\n\t\t\tlet vbuffer = gl.createBuffer();\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);\n\t\t\tgl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n\n\t\t\tlet triCount = 2,\n\t\t\t\tnumItems = vertices.length / triCount;\n\n\t\t\tgl.useProgram(program);\n\n\t\t\tlet time = (Date.now() - firstTime) / 1000.0;\n\t\t\t//program.time = gl.getUniformLocation(program, \"time\");\n\t\t\t//gl.uniform1f(program.time, time);\n\t\t\tprogram.resolution = gl.getUniformLocation(program, \"iResolution\");\n\t\t\tgl.uniform2f(program.resolution, canvas.width, canvas.height);\n\n\t\t\tprogram.aVertexPosition = gl.getAttribLocation(program, \"aVertexPosition\");\n\t\t\tgl.enableVertexAttribArray(program.aVertexPosition);\n\t\t\tgl.vertexAttribPointer(program.aVertexPosition, triCount, gl.FLOAT, false, 0, 0);\n\n\t\t\tgl.drawArrays(gl.TRIANGLES, 0, numItems);\n\n\t\t\tif (time >= this.options.benchmarkDuration) {\n\t\t\t\t// remove canvas from DOM\n\t\t\t\tdocument.body.removeChild(canvas);\n\n\t\t\t\tthis.benchmarkFPS = nbFrames / time;\n\t\t\t\tthis.currentQualityValue = this._getQualityValue(this.benchmarkFPS);\n\t\t\t\tthis.currentQualityName = this._getQualityName(this.currentQualityValue);\n\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(this.benchmarkFPS, this.currentQualityName, this.currentQualityValue);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trequestAnimationFrame(f);\n\t\t\t}\n\t\t})();\n\n\t\treturn canvas;\n\t}\n\n\tisWebGLenabled() {\n\t\treturn this.webGLenabled;\n\t}\n\n\tisHardwareAccelerated() {\n\t\treturn this.hardwareAccelerated;\n\t}\n\n}\n\nmodule.exports = WebGLQualifier;\n","module.exports = \"// simple raytracing example\\n// a sphere + a plane\\n// if it's hard to deal with this shader, be assured your gc is slow...\\n\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\nuniform vec2 iResolution;\\n\\n//void main() { gl_FragColor = vec4(1.0); }\\n\\nfloat sdPlane(vec3 p) {\\n    return p.y;\\n}\\n\\nfloat sdSphere(vec3 p, float s) {\\n    return length(p) - s;\\n}\\n\\n//----------------------------------------------------------------------\\n\\nvec2 opU( vec2 d1, vec2 d2 ) {\\n    return (d1.x<d2.x) ? d1 : d2;\\n}\\n\\n//----------------------------------------------------------------------\\n\\nvec2 map(in vec3 pos) {\\n    return opU(vec2(sdPlane(pos), 1.0), vec2(sdSphere(pos - vec3(0.0,0.25, 0.0), 0.25), 46.9));\\n}\\n\\nvec2 castRay( in vec3 ro, in vec3 rd ) {\\n    float tmin = 1.0;\\n    float tmax = 20.0;\\n\\n    float precis = 0.002;\\n    float t = tmin;\\n    float m = -1.0;\\n    for( int i=0; i<50; i++ ) {\\n        vec2 res = map( ro+rd*t );\\n        if( res.x<precis || t>tmax ) break;\\n        t += res.x;\\n        m = res.y;\\n    }\\n\\n    if( t>tmax ) m=-1.0;\\n    return vec2( t, m );\\n}\\n\\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\\n    float res = 1.0;\\n    float t = mint;\\n    for( int i=0; i<16; i++ )\\n    {\\n        float h = map( ro + rd*t ).x;\\n        res = min( res, 8.0*h/t );\\n        t += clamp( h, 0.02, 0.10 );\\n        if( h<0.001 || t>tmax ) break;\\n    }\\n    return clamp( res, 0.0, 1.0 );\\n\\n}\\n\\nvec3 calcNormal( in vec3 pos ) {\\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\\n    vec3 nor = vec3(\\n    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\\n    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\\n    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\\n    return normalize(nor);\\n}\\n\\nfloat calcAO( in vec3 pos, in vec3 nor ) {\\n    float occ = 0.0;\\n    float sca = 1.0;\\n    for( int i=0; i<5; i++ )\\n    {\\n        float hr = 0.01 + 0.12*float(i)/4.0;\\n        vec3 aopos =  nor * hr + pos;\\n        float dd = map( aopos ).x;\\n        occ += -(dd-hr)*sca;\\n        sca *= 0.95;\\n    }\\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\\n}\\n\\nvec3 render( in vec3 ro, in vec3 rd ) {\\n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\\n    vec2 res = castRay(ro,rd);\\n    float t = res.x;\\n    float m = res.y;\\n    if( m>-0.5 ) {\\n        vec3 pos = ro + t*rd;\\n        vec3 nor = calcNormal( pos );\\n        vec3 ref = reflect( rd, nor );\\n\\n        // material\\n        col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\\n\\n        if( m<1.5 )\\n        {\\n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\\n            col = 0.4 + 0.1*f*vec3(1.0);\\n        }\\n\\n        // lighitng\\n        float occ = calcAO( pos, nor );\\n        vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\\n        float dom = smoothstep( -0.1, 0.1, ref.y );\\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\\n\\n        dif *= softshadow( pos, lig, 0.02, 2.5 );\\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\\n\\n        vec3 lin = vec3(0.0);\\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\\n        lin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\\n        col = col*lin;\\n\\n        col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\\n\\n    }\\n\\n    return vec3( clamp(col,0.0,1.0) );\\n}\\n\\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\\n    vec3 cw = normalize(ta-ro);\\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\\n    vec3 cu = normalize( cross(cw,cp) );\\n    vec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, cw );\\n}\\n\\nvoid main() {\\n    vec2 q = gl_FragCoord.xy/iResolution.xy;\\n    vec2 p = -1.0+2.0*q;\\n    p.x *= iResolution.x/iResolution.y;\\n\\n    float time = 15.0;// + iGlobalTime;\\n\\n    // camera\\n    vec3 ro = vec3(-0.5+1.5*cos(0.1*time), 1.0, -0.5 + 1.5*sin(0.1*time));\\n    vec3 ta = vec3(0.0, 0.0, 0.0);\\n\\n    // camera-to-world transformation\\n    mat3 ca = setCamera( ro, ta, 0.0 );\\n\\n    // ray direction\\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\\n\\n    // render\\n    vec3 col = render( ro, rd );\\n\\n    col = pow( col, vec3(0.4545) );\\n\\n    gl_FragColor = vec4(col, 1.0);\\n}\\n\";\n","module.exports = \"attribute vec2 aVertexPosition;\\n\\nvoid main() {\\n    gl_Position = vec4(aVertexPosition, 0.0, 1.0);\\n}\\n\";\n"]}